#!/usr/bin/perl -lw

use strict;
use warnings;

use Getopt::Long;
use Pod::Usage;

## Set default configuration for Getopt::Long ##
# Minimum word length
my $Min_Length = 4;
# Maximum word length
my $Max_Length = 10;
# Number of words in string
my $Num_Words = 3;
# Character to separate words in string
my $Word_Separator = '.';
# Dictionary to draw words from
my $Words = "/usr/share/dict/words";
# Help stuff
my $help = 0;
my $pod = 0;
# Run the test suite
my $test = 0;

GetOptions( 'min|m=i'         => \$Min_Length,
            'max|l=i'         => \$Max_Length,
            'num|n=i'         => \$Num_Words,
            'separator|s=s'   => \$Word_Separator,
            'dictionary|d=s'  => \$Words,
            'help|h'          => \$help,
            'pod|man|p'       => \$pod,
            'test|t'          => \$test
          );

pod2usage(1) if $help;
pod2usage(-exitval => 0, -verbose => 2) if $pod;

# Self test if --test is passed in
test() if $test;

# Run the main program
print main();

# The main program
sub main {
    my @words;
    open my $fh, "<", $Words or die $!;
    my $count = 0;
    while (my $line = <$fh>) {
        chomp $line;

        # Ignore words that are too short or too long.
        next if length $line > $Max_Length or length $line < $Min_Length;

        # Guffa's algorithm for reading random lines out of a file without
        # storing them all in memory.
        $count++;
        if ( $count <= $Num_Words ) {
            $words[$count-1] = $line;
        } elsif ( rand($count) <= $Num_Words ) {
            $words[rand($Num_Words)] = $line;
        }
    }

    return join $Word_Separator, @words;
}

# Self test
sub test {
    require Test::More;
    Test::More->import;

    my $output = main();
    my @words = split m{\Q$Word_Separator\E}, $output;

    is( scalar @words, $Num_Words, "output $Num_Words words" );

    for my $word (@words) {
        like( $word, qr/^\w+$/, "  '$word' is a word" );
        cmp_ok( length $word, '<=', $Max_Length, "  it's not too long" );
        cmp_ok( length $word, '>=', $Min_Length, "  and not too short" );
    }

    done_testing();
    exit;
}


__END__

=head1 NAME

dicepass - generate strong, pronouncable, rememberable passwords

=head1 SYNOPSIS

    dicepass -m 4 -l 10 -n 3 -s "." -d "/usr/share/dict/words"

Possible parameters are

  --min/-m <integer>            The minimum length for words to use
  --max/-l <integer>            The maximum length for words to use
  --num/-n <integer>            The number of words to use
  --separator/-s <string>       The string to use to separate words
  --dictionary/-d <filename>    The dictionary to draw words from
  --help/-h                     Print this synopsis
  --pod/--man/-p                Print the full documentation
  --test/-t                     Run the self-test

All parameters are optional, with the following default values:

=over

=item C<--min>/C<-m>: 4

=item C<--max>/C<-l>: 10

=item C<--num>/C<-n>: 3

=item C<--separator>/C<-s>: "."

=item C<--dictionary>/C<-d>: "/usr/share/dict/words"

=back

=head1 DESCRIPTION

dicepass generates strong passwords you can remember by stringing
together dictionary words.  It balances security with convenience to
ensure you, the user, will use good passwords.

Simply run the program from a command line and it will give you a
pretty good password.  Don't like it?  Run it again.

Some example passwords generated by dicepass:

    laceless.ours.magneoptic
    against.Cogswellia.mila
    sobering.rukh.bromomania
    gundy.consonance.tonetic

=head1 FAQ

=head2 Development

=head3 I want to help!

Great!  We're on L<Github|https://github.com/schwern/dicepass>.  Send
us an L<issue|https://github.com/schwern/dicepass/issues> and consider
L<making a contribution|https://help.github.com/articles/fork-a-repo>.

=head3 I have an idea to make dicepass even better!

Great!  L<Tell us about it|https://github.com/schwern/dicepass/issues>!

=head3 I want to help, but I don't know how to use Git.

That's ok, you can L<edit this file in your browser|https://github.com/schwern/dicepass/edit/master/dicepass> and Github will take care of the rest.

=head3 I found a bug!

Great!  Well... not great... but L<tell us about it|https://github.com/schwern/dicepass/issues>!

=head3 I'm not sure it's a bug...

L<Tell us about it|https://github.com/schwern/dicepass/issues> anyway!

Don't wait until you have a solution, don't worry if you don't have
all the information, tell us as soon as you have the problem.  Any
problem, concern, improvement, feature, annoyance, typo... we want to
hear from you.  Really!  Nothing can be improved unless we know about
it.

=head2 Security

=head3 Aren't dictionary words insecure?

Yes, if your password is just a dictionary word.  Even with easy to
guess replacements (the letter o to 0, for example) they can be easily
brute forced.  The standard OS X dictionary of 200,000 words means only 200,000
passwords need to be checked, multipled by each common letter
replacement trick.  Nothing for modern computers.

But with each word added, the problem becomes exponentially harder to
brute force.  Picking three words at random from a 200,000 word
dictionary leads to 8,000,000,000,000,000 possibilities which is
pretty good.

See L<http://xkcd.com/936/>

=head3 Why use this instead of a random string?

A bunch of random characters is effectively impossible to crack, but
security is not just about numbers.  The biggest security hole is
I<you> the human.

A good security system must be both secure I<and> convenient.  If it
is not convenient, the users will simply circumvent it.  If your
passwords are all impossible difficult to remember gobblty gook you
will use weaker passwords, or start reusing passwords.


=head3 Why use this instead of a browser based app?

Short version, you could be giving your password to an attacker.

Passwords are typically not directly stored, even encrypted.  It is
"hashed", converted to a bunch of apparently random characters but in
such a way that only your password will produce that same bunch of
characters and the process cannot be reversed.  This is also known as
a "checksum".

This is why a well run organization cannot tell you
what your password was if you forget it, they actually do not know.
When you log in, the password you enter is hashed and compared against
the hash in their database.  If they match, they know you entered the
right password without knowing what your password is.

Attackers pass around huge lists of common passwords and common
variations.  First, they will steal the hashed password file from an
organization.  Then they will try everything on their list and see
what matches.  If your password gets on that list, it doesn't matter
how clever or random it is, it doesn't matter if they don't know your
username, it is compromised.

A clever attacker would set up a web site to generate strong passwords
for users.  Every password they hand out would go straight onto their
list, your password would be pre-compromised.  Even if the site is
setup with the best of intentions, your connection to that site may be
insecure, or the site may have been quietly compromised, or your
browser could be compromised.

It's a simple risk to avoid.


=head3 The NSA has computers that can hack a million Gibsons!

Yes, with enough time and money you can brute force this system in a
not unreasonable amount of time.  Quite honestly, you're not likely
worth the effort.  If you I<are> worth the effort, you shouldn't be
picking your passwords using a program you downloaded off the
internet.

In addition, if a security organization wants to access your accounts,
having a stronger password is unlikely to save you.  There are a
hundred faster and cheaper ways to crack your account than brute
forcing your password.


=head1 COPYRIGHT AND LICNESE

Copyright 2012 by Michael G Schwern E<lt>schwern@pobox.comE<gt>.

This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

See L<http://dev.perl.org/licenses/>

=cut

